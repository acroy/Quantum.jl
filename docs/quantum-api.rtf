{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf190
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green61\blue204;\red102\green0\blue141;\red133\green0\blue175;
\red132\green0\blue2;}
\margl1440\margr1440\vieww16800\viewh17840\viewkind1
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\i\b\fs42 \cf0 Quantum.jl API
\b0\fs24 \
\pard\pardeftab720\sl240
\cf0 A framework for performing operations on user-defined quantum states
\i0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\b \cf0 Overview of Quantum.jl Capabilities\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\b0 \cf0 Finished:\
	- basis, state, state representation, and operator type implementations\
	- tensor product structure for bases and states/state representations\
	- application of arbitrary selection rules to extract subspaces from all types of \
	  Quantum.jl objects\
	- basic arithmetic operations (including linear algebra operations). Examples: \
		- normalization\
		- inner/outer products of Bras and Kets\
		- expectation values/transition matrices\
		- commutator of operators\
	- partial trace of operator representations (entanglement calculations) \
Proposed:	\
	- abstract Expr handling for mixed-basis calculations\
		- basis conversion for mixed-basis Exprs\
	- diagonalization of operators\
	- symmetrization of operators (Young Tableau methods)\
Optional:\
	- HDF5 support\
	- design a system for data visualization of common state properties/operations\
	- package Quantum.jlools as an open-source library that other Julia users can utilize\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97
\i\b\fs42 \
\pard\pardeftab720\sl240

\fs72 \cf0 Type Implementations
\fs42 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\i0\b0\fs24 \cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\sl240

\fs48 \cf0 \ul \ulc0 AbstractTypes\
\pard\pardeftab720\sl240

\b\fs24 \cf0 \ulnone Description
\b0 \
The following list contains the abstract types referenced in this documentation:\
\
\cf2 abstract Dirac\
abstract BraKet <: Dirac\
abstract Bra <: BraKet\
abstract Ket <: BraKet\
abstract AbstractBasis\{K<:BraKet\} <: Dirac\cf0 \
\
The NOT operator (!) can be applied to Bra ad Ket types to alternate between the two:\
\cf2 !(K::Type\{Ket\}) = Bra\
!(B::Type\{Bra\}) = Ket\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\sl240

\fs48 \cf0 \ul State
\i\fs36 \ulnone \
\pard\pardeftab720\sl240

\i0\fs24 \cf0 \ul \
\pard\pardeftab720\sl240

\b \cf0 \ulnone Description
\b0 \
A 
\i State
\i0  is a type of an object that has only a label (stored as a Vector) and a specification of whether it belongs to Ket-space or Bra-space (this property is referred to as \'93kind\'94). A state is parameterized by its kind; thus, states are either of type State\{Bra\} or State\{Ket\}  \
\pard\pardeftab720
\cf0 \
\
\pard\pardeftab720\sl240

\b \cf0 Constructors\

\b0 \
\pard\pardeftab720
\cf0 \
\
\
\
\
\
\pard\pardeftab720\sl240
\cf0 \

\b Related Methods\
\pard\pardeftab720\sl240

\b0 \cf3 normalize\cf0 (S::State)\
normalizes the coefficients of S\
\
\cf3 tensor\cf0 (A::Vector...)\
recursively calls vectensor() on all vectors listed, effectively taking the tensor product A1 cross A2 cross\'85cross AN and returning the result. This vector has elements\
of the form \{A1_i, A2_j,\'85,An_k\}.\
\
\cf3 tensor\cf0 \{S<:String, B<:AbstractBasis\}(name::S, bases::B...)\
returns a TensorBasis formed from the input bases\
\
\cf3 components\cf0 (B::TensorBasis)\
returns B.basis_array\
\
\cf4 extract\cf0 \{B::AbstractBasis\}(B<:Basis, f::Function, name=B.name): \
#Note: filter based on label_dict, not label_arr\
returns a sub-basis formed from the basis labels of B for which f(label)==true. The ordering of the sub-basis follows that of the original basis\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\sl240

\fs48 \cf0 \ul \
\
\
Basis
\i\fs36 \ulnone \
\pard\pardeftab720\sl240

\i0\b\fs24 \cf0 \
Description
\b0 \
A basis is a mapping of labels onto the indices of a state vector representing a given Hilbert subspace. The basis is a subspace that has been selected according to some arbitrary labeling or behavioral pattern, as defined by the user. It provides a label for each position in a given state vector. A graph theoretic approach to thinking about bases would be to consider the basis as the map necessary to traverse a state graph, whose nodes are the states forming a given Hilbert subspace. \
	Taking the tensor product of Basis objects results in a new object of type TensorBasis, which points to the original \'93separable\'94 basis objects in addition to storing the new multi-system basis that resulted from taking the tensor product. This allows for the optimization of operations on matrices/vectors represented in a TensorBasis (for example, taking the partial trace of an operator)\
\

\b Implementation
\b0 \
abstract \cf2 AbstractBasis
\i \cf0 \

\i0 \
immutable Basis\{K<:BraKet\} <: AbstractBasis\{K\}\
	label\
	states::Vector\{State\{K\}\}\
	label_map::Dict\{Vector, Int\}\
end\
\
immutable TensorBasis\{K<:BraKet\} <: AbstractBasis\{K\}\
	bases::Vector\{Basis\{K\}\}\
	states::Vector\{State\{K\}\}\
	label_map::Dict\{Vector, Int\}\
end\
\

\b Constructors\

\b0 \cf2 Basis\cf0 \{S<:String, Labels<:Any\}(name::S, label_dict::Dict\{Labels, Int64\})\
\cf2 Basis\cf0 \{S<:String, A<:Array\}(name::S, label_array::A)\
\cf2 TensorBasis\cf0 \{S<:String, B<:AbstractBasis\}(name::S, label_dict::Dict\{Array, Int\}, basis_array::Array\{B\})\
\cf2 TensorBasis\cf0 \{S<:String, B<:AbstractBasis\}(name::S, label_array::Array, basis_array::Array\{B\})\
\
\
\
\
\
\
\

\b Related Methods\
\pard\pardeftab720\sl240

\b0 \cf3 vectensor\cf0 (A::Vector, B::Vector)\
Takes the tensor product A cross B and returns the result, a vector whose elements are of the form \{A_i, B_j\}\
\
\cf3 tensor\cf0 (A::Vector...)\
recursively calls vectensor() on all vectors listed, effectively taking the tensor product A1 cross A2 cross\'85cross AN and returning the result. This vector has elements\
of the form \{A1_i, A2_j,\'85, An_k\}.\
\
\cf3 tensor\cf0 \{S<:String, B<:AbstractBasis\}(name::S, bases::B...)\
returns a TensorBasis formed from the input bases\
\
\cf3 components\cf0 (B::TensorBasis)\
returns B.basis_array\
\
\cf4 extract\cf0 \{B::AbstractBasis\}(B<:Basis, f::Function, name=B.name): \
#Note: filter based on label_dict, not label_arr\
returns a sub-basis formed from the basis labels of B for which f(label)==true. The ordering of the sub-basis follows that of the original basis\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\sl240
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\sl240

\i \cf0 From here on out is just an amalgamation of random ideas, to be organized later.
\i0 \
\pard\pardeftab720
\cf0 \
\pard\pardeftab720\sl240
\cf0 These mappings also can be used to denote operators in given bases:\
OPERATORS\
op = Operator(name, bases)\
typeof(op.name): \cf5 Any or String?\cf0 \
typeof(op.bases): Dict\{Basis State Labels, Matrix formulation in corresponding basis\}\
\pard\pardeftab720
\cf0 \
\pard\pardeftab720\sl240
\cf0 Operators can act as converters from one basis to another, editing both the internal label of a state and its vector contents. \cf5 The behavior of multi-basis operators on multi-basis states?\cf0 \
\pard\pardeftab720\sl240
\cf5 State operations to form new operators?\cf0 \
\pard\pardeftab720
\cf0 \
\pard\pardeftab720\sl240
\cf0 BASIS CONVERSION\
A converter is a graph whose edges are coefficient matrices and whose vertices are basis names (strings). \
	\
\{\'93A\'94\}--[AB]--\{\'93B\'94\}\
The above is an example of a converter; we\'92ll refer to it as C.\
The below is an example converter function for a single-basis state:\
convert(NewB::Basis, S::State, C::Converter)\
\pard\pardeftab720\fi960\sl240
\cf0 OldB = getkeys(S.bases)[1] #get basis name \
dest = NewB.name\
dest_reached = false\
\pard\pardeftab720
\cf0 \
\pard\pardeftab720\fi960\sl240
\cf0 while !dest_reached #while not at dest\
\pard\pardeftab720\sl240
\cf0 	# step through graph along shortest path to dest, at each step \
	# multiply state by relevant coefficient matrix\
	# if moving in opposite \'93direction\'94 of coefficient matrix (ex. from \'93B\'94 to \'93A\'94 above),\
	# multiply by transpose coefficient matrix instead. \
\pard\pardeftab720
\cf0 \
\pard\pardeftab720\fi960\sl240
\cf0 end\
\pard\pardeftab720\sl240
\cf0 	setbasis!(State, Basis)\
	return state\
end\
\pard\pardeftab720
\cf0 \
\pard\pardeftab720\fi960\sl240
\cf0 	}